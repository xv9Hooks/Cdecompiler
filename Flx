
local FLX = {
    version = "FLX-2.0",
    config = {
        verbose = false,
        max_regs = 256,
        indent_str = "    ",
    }
}

local function u8(s, i)
    if i > #s then return 0 end
    return string.byte(s, i)
end

local function u32_le(s, i)
    if i + 3 > #s then return 0 end
    local b1, b2, b3, b4 = string.byte(s, i, i + 3)
    return b1 + b2 * 256 + b3 * 65536 + b4 * 16777216
end

local function f64_le(s, i)
    if i + 7 > #s then return 0.0 end
    if string.unpack then
        return (string.unpack("<d", s, i))
    end
    local b1, b2, b3, b4, b5, b6, b7, b8 = string.byte(s, i, i + 7)
    local sign = (b8 >= 128) and -1 or 1
    local exp = ((b8 % 128) * 16) + math.floor(b7 / 16)
    local mantissa = ((b7 % 16) * 2^48) + (b6 * 2^40) + (b5 * 2^32)
        + (b4 * 2^24) + (b3 * 2^16) + (b2 * 2^8) + b1
    if exp == 0 and mantissa == 0 then return 0.0
    elseif exp == 2047 then return (mantissa == 0) and (sign * math.huge) or (0/0)
    elseif exp == 0 then return sign * (mantissa / 2^52) * 2^(-1022)
    else return sign * (1 + mantissa / 2^52) * 2^(exp - 1023) end
end

-- Luau VarInt (unsigned, variable length)
local function read_varint(data, pos)
    local val = 0
    local shift = 0
    while pos <= #data do
        local b = string.byte(data, pos)
        pos = pos + 1
        val = val + (b % 128) * (2 ^ shift)
        shift = shift + 7
        if b < 128 then break end
    end
    return val, pos
end

local function read_string_varint(data, pos)
    local len
    len, pos = read_varint(data, pos)
    if len == 0 then return "", pos end
    if pos + len - 1 > #data then return "", pos end
    local s = string.sub(data, pos, pos + len - 1)
    return s, pos + len
end

local function shallow_copy(t)
    if not t then return {} end
    local o = {}
    for k, v in pairs(t) do o[k] = v end
    return o
end

-- ==================================================
-- 2) LUAU OPCODE DEFINITIONS (Bytecode v3-v6)
-- ==================================================
-- Luau uses a completely different opcode set from standard Lua

local LuauOpcode = {
    LOP_NOP = 0,
    LOP_BREAK = 1,
    LOP_LOADNIL = 2,
    LOP_LOADB = 3,
    LOP_LOADN = 4,
    LOP_LOADK = 5,
    LOP_MOVE = 6,
    LOP_GETGLOBAL = 7,
    LOP_SETGLOBAL = 8,
    LOP_GETUPVAL = 9,
    LOP_SETUPVAL = 10,
    LOP_CLOSEUPVALS = 11,
    LOP_GETIMPORT = 12,
    LOP_GETTABLE = 13,
    LOP_SETTABLE = 14,
    LOP_GETTABLEKS = 15,
    LOP_SETTABLEKS = 16,
    LOP_GETTABLEN = 17,
    LOP_SETTABLEN = 18,
    LOP_NEWCLOSURE = 19,
    LOP_NAMECALL = 20,
    LOP_CALL = 21,
    LOP_RETURN = 22,
    LOP_JUMP = 23,
    LOP_JUMPBACK = 24,
    LOP_JUMPIF = 25,
    LOP_JUMPIFNOT = 26,
    LOP_JUMPIFEQ = 27,
    LOP_JUMPIFLE = 28,
    LOP_JUMPIFLT = 29,
    LOP_JUMPIFNOTEQ = 30,
    LOP_JUMPIFNOTLE = 31,
    LOP_JUMPIFNOTLT = 32,
    LOP_ADD = 33,
    LOP_SUB = 34,
    LOP_MUL = 35,
    LOP_DIV = 36,
    LOP_MOD = 37,
    LOP_POW = 38,
    LOP_ADDK = 39,
    LOP_SUBK = 40,
    LOP_MULK = 41,
    LOP_DIVK = 42,
    LOP_MODK = 43,
    LOP_POWK = 44,
    LOP_AND = 45,
    LOP_OR = 46,
    LOP_ANDK = 47,
    LOP_ORK = 48,
    LOP_CONCAT = 49,
    LOP_NOT = 50,
    LOP_MINUS = 51,
    LOP_LENGTH = 52,
    LOP_NEWTABLE = 53,
    LOP_DUPTABLE = 54,
    LOP_SETLIST = 55,
    LOP_FORNPREP = 56,
    LOP_FORNLOOP = 57,
    LOP_FORGLOOP = 58,
    LOP_FORGPREP_INEXT = 59,
    LOP_DEP_FORGLOOP_INEXT = 60,
    LOP_FORGPREP_NEXT = 61,
    LOP_DEP_FORGLOOP_NEXT = 62,
    LOP_GETVARARGS = 63,
    LOP_DUPCLOSURE = 64,
    LOP_PREPVARARGS = 65,
    LOP_LOADKX = 66,
    LOP_JUMPX = 67,
    LOP_FASTCALL = 68,
    LOP_COVERAGE = 69,
    LOP_CAPTURE = 70,
    LOP_SUBRK = 71,
    LOP_DIVRK = 72,
    LOP_FASTCALL1 = 73,
    LOP_FASTCALL2 = 74,
    LOP_FASTCALL2K = 75,
    LOP_FORGPREP = 76,
    LOP_JUMPXEQKNIL = 77,
    LOP_JUMPXEQKB = 78,
    LOP_JUMPXEQKN = 79,
    LOP_JUMPXEQKS = 80,
    LOP_IDIV = 81,
    LOP_IDIVK = 82,
}

-- Reverse lookup
local LuauOpName = {}
for name, code in pairs(LuauOpcode) do
    LuauOpName[code] = name
end

-- Instruction encoding types
-- Luau uses: A, AB, ABC, AD, AE, iAsBx etc.
local LuauOpMode = {}
-- Most Luau ops: opcode(8) A(8) B(8) C(8) = 32 bits
-- Some use:     opcode(8) A(8) D(16-signed) = 32 bits

local function luau_decode_ABC(instr)
    local op = instr % 256
    local A = math.floor(instr / 256) % 256
    local B = math.floor(instr / 65536) % 256
    local C = math.floor(instr / 16777216) % 256
    return op, A, B, C
end

local function luau_decode_AD(instr)
    local op = instr % 256
    local A = math.floor(instr / 256) % 256
    local D = math.floor(instr / 65536)
    -- D is signed 16-bit
    if D >= 32768 then D = D - 65536 end
    return op, A, D
end

local function luau_decode_AE(instr)
    local op = instr % 256
    local E = math.floor(instr / 256)
    -- E is signed 24-bit
    if E >= 8388608 then E = E - 16777216 end
    return op, E
end

-- Which opcodes use AD format (signed D operand)
local AD_opcodes = {
    [LuauOpcode.LOP_LOADN] = true,
    [LuauOpcode.LOP_LOADK] = true,
    [LuauOpcode.LOP_GETGLOBAL] = true,
    [LuauOpcode.LOP_SETGLOBAL] = true,
    [LuauOpcode.LOP_GETIMPORT] = true,
    [LuauOpcode.LOP_GETTABLEKS] = true,
    [LuauOpcode.LOP_SETTABLEKS] = true,
    [LuauOpcode.LOP_NEWCLOSURE] = true,
    [LuauOpcode.LOP_NAMECALL] = true,
    [LuauOpcode.LOP_JUMP] = true,
    [LuauOpcode.LOP_JUMPBACK] = true,
    [LuauOpcode.LOP_JUMPIF] = true,
    [LuauOpcode.LOP_JUMPIFNOT] = true,
    [LuauOpcode.LOP_FORNPREP] = true,
    [LuauOpcode.LOP_FORNLOOP] = true,
    [LuauOpcode.LOP_FORGLOOP] = true,
    [LuauOpcode.LOP_FORGPREP_INEXT] = true,
    [LuauOpcode.LOP_FORGPREP_NEXT] = true,
    [LuauOpcode.LOP_GETVARARGS] = true,
    [LuauOpcode.LOP_DUPCLOSURE] = true,
    [LuauOpcode.LOP_LOADKX] = true,
    [LuauOpcode.LOP_FORGPREP] = true,
    [LuauOpcode.LOP_CALL] = true,
    [LuauOpcode.LOP_RETURN] = true,
    [LuauOpcode.LOP_DUPTABLE] = true,
    [LuauOpcode.LOP_SETLIST] = true,
    [LuauOpcode.LOP_NEWTABLE] = true,
    [LuauOpcode.LOP_COVERAGE] = true,
    [LuauOpcode.LOP_CAPTURE] = true,
}

-- E format (24-bit signed jump)
local E_opcodes = {
    [LuauOpcode.LOP_JUMPX] = true,
}

-- ==================================================
-- 3) LUAU BYTECODE PARSER
-- ==================================================
local LuauDecoder = {}

function LuauDecoder.parse(data)
    if not data or #data < 2 then
        return nil, "data too short"
    end

    local pos = 1

    -- Luau bytecode version
    local version = u8(data, pos); pos = pos + 1

    if version == 0 then
        -- Compilation error message follows
        local errmsg
        errmsg, pos = read_string_varint(data, pos)
        return nil, "Luau compilation error: " .. (errmsg or "unknown")
    end

    if version < 3 or version > 6 then
        return nil, "Unsupported Luau bytecode version: " .. version
    end

    -- v6: type info encoding byte
    local types_version = 0
    if version >= 4 then
        types_version = u8(data, pos); pos = pos + 1
    end

    -- String table
    local string_count
    string_count, pos = read_varint(data, pos)

    local string_table = {}
    for i = 1, string_count do
        local len
        len, pos = read_varint(data, pos)
        if len > 0 and pos + len - 1 <= #data then
            string_table[i] = string.sub(data, pos, pos + len - 1)
            pos = pos + len
        else
            string_table[i] = ""
            pos = pos + len
        end
    end

    -- Prototype table
    local proto_count
    proto_count, pos = read_varint(data, pos)

    local protos = {}
    for pi = 1, proto_count do
        local proto = {}

        -- Header
        proto.maxstacksize = u8(data, pos); pos = pos + 1
        proto.numparams = u8(data, pos); pos = pos + 1
        proto.nups = u8(data, pos); pos = pos + 1
        proto.is_vararg = u8(data, pos); pos = pos + 1

        -- v6: type info
        if version >= 4 and types_version > 0 then
            -- flags byte
            local flags = u8(data, pos); pos = pos + 1
            -- type info size
            local typesize
            typesize, pos = read_varint(data, pos)
            -- skip type info bytes
            if typesize > 0 then
                pos = pos + typesize
            end
        end

        -- Instruction count
        local sizecode
        sizecode, pos = read_varint(data, pos)

        proto.code = {}
        for i = 1, sizecode do
            if pos + 3 > #data then break end
            proto.code[i] = u32_le(data, pos)
            pos = pos + 4
        end

        -- Constants
        local sizek
        sizek, pos = read_varint(data, pos)

        proto.consts = {}
        for i = 1, sizek do
            if pos > #data then break end
            local t = u8(data, pos); pos = pos + 1

            if t == 0 then
                -- NIL
                proto.consts[i] = { type = "nil", value = nil }
            elseif t == 1 then
                -- BOOLEAN
                local v = u8(data, pos); pos = pos + 1
                proto.consts[i] = { type = "boolean", value = (v ~= 0) }
            elseif t == 2 then
                -- NUMBER (double)
                proto.consts[i] = { type = "number", value = f64_le(data, pos) }
                pos = pos + 8
            elseif t == 3 then
                -- STRING (index into string table)
                local idx
                idx, pos = read_varint(data, pos)
                proto.consts[i] = { type = "string", value = string_table[idx] or ("str_" .. idx) }
            elseif t == 4 then
                -- IMPORT (encoded import path)
                local import_id = u32_le(data, pos); pos = pos + 4
                proto.consts[i] = { type = "import", value = import_id }
            elseif t == 5 then
                -- TABLE (key list for DUPTABLE)
                local nkeys
                nkeys, pos = read_varint(data, pos)
                local keys = {}
                for j = 1, nkeys do
                    local kidx
                    kidx, pos = read_varint(data, pos)
                    keys[j] = kidx
                end
                proto.consts[i] = { type = "table", value = keys }
            elseif t == 6 then
                -- CLOSURE (proto index)
                local pidx
                pidx, pos = read_varint(data, pos)
                proto.consts[i] = { type = "closure", value = pidx }
            elseif t == 7 then
                -- VECTOR
                local x = f64_le(data, pos); pos = pos + 4 -- actually float32
                local y = f64_le(data, pos); pos = pos + 4
                local z = f64_le(data, pos); pos = pos + 4
                -- Re-read as float32
                if string.unpack then
                    pos = pos - 12
                    x = (string.unpack("<f", data, pos)); pos = pos + 4
                    y = (string.unpack("<f", data, pos)); pos = pos + 4
                    z = (string.unpack("<f", data, pos)); pos = pos + 4
                end
                proto.consts[i] = { type = "vector", value = {x, y, z} }
            else
                proto.consts[i] = { type = "unknown", value = nil }
            end
        end

        -- Child protos
        local sizep
        sizep, pos = read_varint(data, pos)
        proto.child_protos = {}
        for i = 1, sizep do
            local pidx
            pidx, pos = read_varint(data, pos)
            proto.child_protos[i] = pidx
        end

        -- Line info (optional, used for debugging)
        proto.linedefined = 0
        local has_lineinfo = u8(data, pos); pos = pos + 1
        if has_lineinfo ~= 0 then
            local linegaplog2 = u8(data, pos); pos = pos + 1
            
            -- Intervals
            local intervals_count = math.floor((sizecode - 1) / (2 ^ linegaplog2)) + 1
            
            -- Line info: each is a byte offset
            for i = 1, sizecode do
                if pos > #data then break end
                local _ = u8(data, pos); pos = pos + 1
            end
            
            -- Absolute line info
            for i = 1, intervals_count do
                if pos + 3 > #data then break end
                local absline = u32_le(data, pos); pos = pos + 4
            end
        end

        -- Debug info
        local has_debuginfo = u8(data, pos); pos = pos + 1
        proto.local_names = {}
        proto.upvalue_names = {}

        if has_debuginfo ~= 0 then
            -- Local variables
            local sizelocvars
            sizelocvars, pos = read_varint(data, pos)
            for i = 1, sizelocvars do
                local name_idx
                name_idx, pos = read_varint(data, pos)
                local startpc
                startpc, pos = read_varint(data, pos)
                local endpc
                endpc, pos = read_varint(data, pos)
                local reg = u8(data, pos); pos = pos + 1
                proto.local_names[i] = {
                    name = string_table[name_idx] or ("var" .. i),
                    startpc = startpc,
                    endpc = endpc,
                    reg = reg,
                }
            end

            -- Upvalue names
            local sizeupvalues
            sizeupvalues, pos = read_varint(data, pos)
            for i = 1, sizeupvalues do
                local name_idx
                name_idx, pos = read_varint(data, pos)
                proto.upvalue_names[i] = string_table[name_idx] or ("upval" .. i)
            end
        end

        proto.version = version
        proto.string_table = string_table
        protos[pi] = proto
    end

    -- Main proto index
    local main_proto_idx
    main_proto_idx, pos = read_varint(data, pos)

    return {
        version = version,
        types_version = types_version,
        string_table = string_table,
        protos = protos,
        main_proto = main_proto_idx,
    }
end

-- ==================================================
-- 4) LUAU IMPORT RESOLVER
-- ==================================================
local function resolve_import(import_id, string_table)
    -- Import encoding: count(30..31) | id0(20..29) | id1(10..19) | id2(0..9)
    local count = math.floor(import_id / (2^30))
    local id0 = math.floor(import_id / (2^20)) % 1024
    local id1 = math.floor(import_id / (2^10)) % 1024
    local id2 = import_id % 1024

    local parts = {}
    if count >= 1 and string_table[id0] then
        parts[#parts + 1] = string_table[id0]
    end
    if count >= 2 and string_table[id1] then
        parts[#parts + 1] = string_table[id1]
    end
    if count >= 3 and string_table[id2] then
        parts[#parts + 1] = string_table[id2]
    end

    if #parts == 0 then return "import_" .. import_id end
    return table.concat(parts, ".")
end

-- ==================================================
-- 5) LUAU DECOMPILER (Main Engine)
-- ==================================================

local function get_const_str(proto, idx)
    local k = proto.consts[idx + 1]
    if not k then return "nil" end
    if k.type == "nil" then return "nil"
    elseif k.type == "boolean" then return tostring(k.value)
    elseif k.type == "number" then
        local v = k.value
        if v ~= v then return "0/0"
        elseif v == math.huge then return "math.huge"
        elseif v == -math.huge then return "-math.huge"
        else return tostring(v) end
    elseif k.type == "string" then
        return '"' .. (k.value or ""):gsub('\\', '\\\\'):gsub('"', '\\"'):gsub('\n', '\\n'):gsub('\r', '\\r'):gsub('\0', '\\0') .. '"'
    elseif k.type == "import" then
        return resolve_import(k.value, proto.string_table)
    elseif k.type == "vector" then
        local v = k.value
        return string.format("Vector3.new(%s, %s, %s)", tostring(v[1]), tostring(v[2]), tostring(v[3]))
    else
        return "nil --[[ unknown const type ]]"
    end
end

local function get_const_value(proto, idx)
    local k = proto.consts[idx + 1]
    if not k then return nil end
    return k.value
end

local function get_string_from_aux(proto, aux_word)
    -- AUX word for GETTABLEKS etc contains index into string table
    -- Actually the constant pool index
    local k = proto.consts[aux_word + 1]
    if k and k.type == "string" then
        return k.value
    end
    return nil
end

-- Get local var name for register at given PC
local function get_local_name(proto, reg, pc)
    for _, lv in ipairs(proto.local_names or {}) do
        if lv.reg == reg and pc >= lv.startpc and pc <= lv.endpc then
            return lv.name
        end
    end
    return nil
end

local function reg_name(proto, reg, pc)
    local name = get_local_name(proto, reg, pc or 0)
    if name and name ~= "" and not name:match("^%(") then
        return name
    end
    return "v" .. reg
end

local function decompile_proto_luau(chunk, proto_idx, depth)
    depth = depth or 0
    local protos = chunk.protos
    local proto = protos[proto_idx]
    if not proto then return "-- FLX: invalid proto index " .. proto_idx end

    local code = proto.code
    local ncode = #code
    local indent_level = depth
    local lines = {}
    local indent_str = FLX.config.indent_str

    local function get_indent()
        return string.rep(indent_str, indent_level)
    end

    local function emit(line)
        lines[#lines + 1] = line
    end

    -- Track scope for variable declarations
    local declared = {}
    local function var_decl(name)
        if not declared[name] then
            declared[name] = true
            return "local "
        end
        return ""
    end

    -- Parameter names
    local params = {}
    for i = 0, proto.numparams - 1 do
        local name = reg_name(proto, i, 0)
        params[#params + 1] = name
        declared[name] = true
    end
    if proto.is_vararg > 0 then
        params[#params + 1] = "..."
    end

    -- Function header
    if depth == 0 then
        -- Main chunk, no function wrapper typically
    else
        emit(get_indent() .. "function(" .. table.concat(params, ", ") .. ")")
        indent_level = indent_level + 1
    end

    -- Skip tracking
    local skip_until = 0

    -- For loop tracking
    local for_loop_ends = {} -- pc -> true means "end" at this pc
    local for_generic_ends = {}

    local pc = 1
    while pc <= ncode do
        if pc <= skip_until then
            pc = pc + 1
            goto continue
        end

        local instr = code[pc]
        local op = instr % 256
        local A, B, C, D, E

        -- Decode based on format
        if E_opcodes[op] then
            op, E = luau_decode_AE(instr)
        elseif AD_opcodes[op] then
            op, A, D = luau_decode_AD(instr)
        else
            op, A, B, C = luau_decode_ABC(instr)
        end

        local ind = get_indent()
        local opname = LuauOpName[op] or ("OP_" .. op)

        -- Check if we hit a for-loop end
        if for_loop_ends[pc] then
            indent_level = math.max(depth + (depth > 0 and 1 or 0), indent_level - 1)
            ind = get_indent()
            emit(ind .. "end")
            for_loop_ends[pc] = nil
        end
        if for_generic_ends[pc] then
            indent_level = math.max(depth + (depth > 0 and 1 or 0), indent_level - 1)
            ind = get_indent()
            emit(ind .. "end")
            for_generic_ends[pc] = nil
        end

        -- NOP / BREAK
        if op == LuauOpcode.LOP_NOP then
            -- skip

        elseif op == LuauOpcode.LOP_BREAK then
            emit(ind .. "break")

        -- LOADNIL
        elseif op == LuauOpcode.LOP_LOADNIL then
            local name = reg_name(proto, A, pc)
            emit(ind .. var_decl(name) .. name .. " = nil")

        -- LOADB (load boolean)
        elseif op == LuauOpcode.LOP_LOADB then
            local name = reg_name(proto, A, pc)
            local val = (B ~= 0) and "true" or "false"
            emit(ind .. var_decl(name) .. name .. " = " .. val)
            if C ~= 0 then
                -- skip next C instructions
                skip_until = pc + C
            end

        -- LOADN (load number from D operand)
        elseif op == LuauOpcode.LOP_LOADN then
            local name = reg_name(proto, A, pc)
            emit(ind .. var_decl(name) .. name .. " = " .. tostring(D))

        -- LOADK (load constant)
        elseif op == LuauOpcode.LOP_LOADK then
            local name = reg_name(proto, A, pc)
            local val = get_const_str(proto, D)
            emit(ind .. var_decl(name) .. name .. " = " .. val)

        -- MOVE
        elseif op == LuauOpcode.LOP_MOVE then
            local dst = reg_name(proto, A, pc)
            local src = reg_name(proto, B, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. src)

        -- GETGLOBAL
        elseif op == LuauOpcode.LOP_GETGLOBAL then
            local name = reg_name(proto, A, pc)
            -- AUX word contains string constant index
            local aux = code[pc + 1] or 0
            local gname = get_const_str(proto, aux)
            -- Remove quotes from string constant
            if gname:sub(1,1) == '"' then gname = gname:sub(2, -2) end
            emit(ind .. var_decl(name) .. name .. " = " .. gname)
            skip_until = pc + 1

        -- SETGLOBAL
        elseif op == LuauOpcode.LOP_SETGLOBAL then
            local src = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local gname = get_const_str(proto, aux)
            if gname:sub(1,1) == '"' then gname = gname:sub(2, -2) end
            emit(ind .. gname .. " = " .. src)
            skip_until = pc + 1

        -- GETUPVAL
        elseif op == LuauOpcode.LOP_GETUPVAL then
            local dst = reg_name(proto, A, pc)
            local upname = proto.upvalue_names[B + 1] or ("upval" .. B)
            emit(ind .. var_decl(dst) .. dst .. " = " .. upname)

        -- SETUPVAL
        elseif op == LuauOpcode.LOP_SETUPVAL then
            local src = reg_name(proto, A, pc)
            local upname = proto.upvalue_names[B + 1] or ("upval" .. B)
            emit(ind .. upname .. " = " .. src)

        -- CLOSEUPVALS
        elseif op == LuauOpcode.LOP_CLOSEUPVALS then
            -- Internal, skip

        -- GETIMPORT (optimized global access like print, math.floor)
        elseif op == LuauOpcode.LOP_GETIMPORT then
            local dst = reg_name(proto, A, pc)
            local k = proto.consts[D + 1]
            local import_str
            if k and k.type == "import" then
                import_str = resolve_import(k.value, proto.string_table)
            else
                import_str = get_const_str(proto, D)
            end
            emit(ind .. var_decl(dst) .. dst .. " = " .. import_str)
            -- Skip AUX
            skip_until = pc + 1

        -- GETTABLE R(A) = R(B)[R(C)]
        elseif op == LuauOpcode.LOP_GETTABLE then
            local dst = reg_name(proto, A, pc)
            local tbl = reg_name(proto, B, pc)
            local key = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. tbl .. "[" .. key .. "]")

        -- SETTABLE R(B)[R(C)] = R(A)
        elseif op == LuauOpcode.LOP_SETTABLE then
            local val = reg_name(proto, A, pc)
            local tbl = reg_name(proto, B, pc)
            local key = reg_name(proto, C, pc)
            emit(ind .. tbl .. "[" .. key .. "] = " .. val)

        -- GETTABLEKS R(A) = R(B)[K(AUX)]
        elseif op == LuauOpcode.LOP_GETTABLEKS then
            local dst = reg_name(proto, A, pc)
            local tbl = reg_name(proto, B, pc)
            local aux = code[pc + 1] or 0
            local key = get_const_str(proto, aux)
            local key_raw = key
            if key:sub(1,1) == '"' then key_raw = key:sub(2,-2) end

            if key_raw:match("^[%a_][%w_]*$") then
                emit(ind .. var_decl(dst) .. dst .. " = " .. tbl .. "." .. key_raw)
            else
                emit(ind .. var_decl(dst) .. dst .. " = " .. tbl .. "[" .. key .. "]")
            end
            skip_until = pc + 1

        -- SETTABLEKS R(B)[K(AUX)] = R(A)
        elseif op == LuauOpcode.LOP_SETTABLEKS then
            local val = reg_name(proto, A, pc)
            local tbl = reg_name(proto, B, pc)
            local aux = code[pc + 1] or 0
            local key = get_const_str(proto, aux)
            local key_raw = key
            if key:sub(1,1) == '"' then key_raw = key:sub(2,-2) end

            if key_raw:match("^[%a_][%w_]*$") then
                emit(ind .. tbl .. "." .. key_raw .. " = " .. val)
            else
                emit(ind .. tbl .. "[" .. key .. "] = " .. val)
            end
            skip_until = pc + 1

        -- GETTABLEN R(A) = R(B)[C+1]
        elseif op == LuauOpcode.LOP_GETTABLEN then
            local dst = reg_name(proto, A, pc)
            local tbl = reg_name(proto, B, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. tbl .. "[" .. (C + 1) .. "]")

        -- SETTABLEN R(B)[C+1] = R(A)
        elseif op == LuauOpcode.LOP_SETTABLEN then
            local val = reg_name(proto, A, pc)
            local tbl = reg_name(proto, B, pc)
            emit(ind .. tbl .. "[" .. (C + 1) .. "] = " .. val)

        -- NEWCLOSURE
        elseif op == LuauOpcode.LOP_NEWCLOSURE then
            local dst = reg_name(proto, A, pc)
            local child_idx = proto.child_protos[D + 1]
            if child_idx then
                local child_src = decompile_proto_luau(chunk, child_idx, indent_level)
                emit(ind .. var_decl(dst) .. dst .. " = " .. child_src)
            else
                emit(ind .. var_decl(dst) .. dst .. " = function() end -- proto " .. D)
            end
            -- Skip CAPTURE instructions
            local next_pc = pc + 1
            while next_pc <= ncode do
                local next_op = code[next_pc] % 256
                if next_op == LuauOpcode.LOP_CAPTURE then
                    next_pc = next_pc + 1
                else
                    break
                end
            end
            skip_until = next_pc - 1

        -- DUPCLOSURE
        elseif op == LuauOpcode.LOP_DUPCLOSURE then
            local dst = reg_name(proto, A, pc)
            local k = proto.consts[D + 1]
            if k and k.type == "closure" then
                local child_idx = proto.child_protos[k.value + 1]
                if child_idx then
                    local child_src = decompile_proto_luau(chunk, child_idx, indent_level)
                    emit(ind .. var_decl(dst) .. dst .. " = " .. child_src)
                else
                    emit(ind .. var_decl(dst) .. dst .. " = function() end")
                end
            else
                emit(ind .. var_decl(dst) .. dst .. " = function() end")
            end
            -- Skip CAPTURE instructions
            local next_pc = pc + 1
            while next_pc <= ncode do
                local next_op = code[next_pc] % 256
                if next_op == LuauOpcode.LOP_CAPTURE then
                    next_pc = next_pc + 1
                else
                    break
                end
            end
            skip_until = next_pc - 1

        -- NAMECALL R(A) = R(B):method(...)
        elseif op == LuauOpcode.LOP_NAMECALL then
            local dst = reg_name(proto, A, pc)
            local obj = reg_name(proto, B, pc)
            local aux = code[pc + 1] or 0
            local method = get_const_str(proto, aux)
            if method:sub(1,1) == '"' then method = method:sub(2,-2) end

            -- Next instruction should be CALL
            -- We'll emit the full namecall when we hit CALL
            -- For now just note the self + method
            declared[dst] = true
            declared[reg_name(proto, A + 1, pc)] = true

            -- Store for next CALL
            proto._pending_namecall = {
                obj = obj,
                method = method,
                base_reg = A,
            }
            skip_until = pc + 1

        -- CALL R(A)(R(A+1), ..., R(A+B-1)) -> R(A), ..., R(A+C-2)
        elseif op == LuauOpcode.LOP_CALL then
            -- B = nargs + 1 (0 = vararg), C = nresults + 1 (0 = multi)
            local nargs = (B > 0) and (B - 1) or nil
            local nresults = (C > 0) and (C - 1) or nil

            local func_name
            local is_method = false
            local args = {}

            if proto._pending_namecall and proto._pending_namecall.base_reg == A then
                local nc = proto._pending_namecall
                func_name = nc.obj .. ":" .. nc.method
                is_method = true
                -- Arguments start at A+2 for namecall (A=self, A+1=func)
                if nargs then
                    for i = 1, nargs - 1 do
                        args[#args + 1] = reg_name(proto, A + 1 + i, pc)
                    end
                else
                    args[#args + 1] = "..."
                end
                proto._pending_namecall = nil
            else
                func_name = reg_name(proto, A, pc)
                if nargs then
                    for i = 1, nargs do
                        args[#args + 1] = reg_name(proto, A + i, pc)
                    end
                else
                    args[#args + 1] = "..."
                end
            end

            local call_str = func_name .. "(" .. table.concat(args, ", ") .. ")"

            if nresults and nresults > 0 then
                local rets = {}
                for i = 0, nresults - 1 do
                    local rn = reg_name(proto, A + i, pc)
                    rets[#rets + 1] = rn
                end
                local ret_str = table.concat(rets, ", ")
                local has_new = false
                for _, r in ipairs(rets) do
                    if not declared[r] then has_new = true; break end
                end
                if has_new then
                    for _, r in ipairs(rets) do declared[r] = true end
                    emit(ind .. "local " .. ret_str .. " = " .. call_str)
                else
                    emit(ind .. ret_str .. " = " .. call_str)
                end
            elseif nresults == 0 then
                emit(ind .. call_str)
            else
                local rn = reg_name(proto, A, pc)
                emit(ind .. var_decl(rn) .. rn .. " = " .. call_str)
            end

        -- RETURN
        elseif op == LuauOpcode.LOP_RETURN then
            -- B = nresults + 1 (0 = multi, 1 = no values)
            local nresults = B - 1
            if nresults <= 0 then
                emit(ind .. "return")
            else
                local rets = {}
                for i = 0, nresults - 1 do
                    rets[#rets + 1] = reg_name(proto, A + i, pc)
                end
                emit(ind .. "return " .. table.concat(rets, ", "))
            end

        -- JUMP
        elseif op == LuauOpcode.LOP_JUMP then
            -- D is offset, target = pc + 1 + D
            -- Usually part of structured control flow, emit as goto-like
            -- We'll try to detect if/else/end patterns

        elseif op == LuauOpcode.LOP_JUMPBACK then
            -- Loop back jump

        -- JUMPIF / JUMPIFNOT
        elseif op == LuauOpcode.LOP_JUMPIF then
            local cond = reg_name(proto, A, pc)
            emit(ind .. "if " .. cond .. " then")
            indent_level = indent_level + 1

        elseif op == LuauOpcode.LOP_JUMPIFNOT then
            local cond = reg_name(proto, A, pc)
            emit(ind .. "if not " .. cond .. " then")
            indent_level = indent_level + 1

        -- JUMPIFEQ / JUMPIFNOTEQ
        elseif op == LuauOpcode.LOP_JUMPIFEQ then
            local lhs = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local rhs = reg_name(proto, aux, pc)
            emit(ind .. "if " .. lhs .. " == " .. rhs .. " then")
            indent_level = indent_level + 1
            skip_until = pc + 1

        elseif op == LuauOpcode.LOP_JUMPIFNOTEQ then
            local lhs = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local rhs = reg_name(proto, aux, pc)
            emit(ind .. "if " .. lhs .. " ~= " .. rhs .. " then")
            indent_level = indent_level + 1
            skip_until = pc + 1

        -- JUMPIFLE / JUMPIFNOTLT etc
        elseif op == LuauOpcode.LOP_JUMPIFLE then
            local lhs = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local rhs = reg_name(proto, aux, pc)
            emit(ind .. "if " .. lhs .. " <= " .. rhs .. " then")
            indent_level = indent_level + 1
            skip_until = pc + 1

        elseif op == LuauOpcode.LOP_JUMPIFLT then
            local lhs = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local rhs = reg_name(proto, aux, pc)
            emit(ind .. "if " .. lhs .. " < " .. rhs .. " then")
            indent_level = indent_level + 1
            skip_until = pc + 1

        elseif op == LuauOpcode.LOP_JUMPIFNOTLE then
            local lhs = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local rhs = reg_name(proto, aux, pc)
            emit(ind .. "if " .. lhs .. " > " .. rhs .. " then")
            indent_level = indent_level + 1
            skip_until = pc + 1

        elseif op == LuauOpcode.LOP_JUMPIFNOTLT then
            local lhs = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local rhs = reg_name(proto, aux, pc)
            emit(ind .. "if " .. lhs .. " >= " .. rhs .. " then")
            indent_level = indent_level + 1
            skip_until = pc + 1

        -- JUMPX (long jump)
        elseif op == LuauOpcode.LOP_JUMPX then
            -- E is 24-bit signed offset

        -- JUMPXEQK* (compare with constant and jump)
        elseif op == LuauOpcode.LOP_JUMPXEQKNIL then
            local lhs = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local not_flag = (math.floor(aux / (2^31)) ~= 0)
            if not_flag then
                emit(ind .. "if " .. lhs .. " ~= nil then")
            else
                emit(ind .. "if " .. lhs .. " == nil then")
            end
            indent_level = indent_level + 1
            skip_until = pc + 1

        elseif op == LuauOpcode.LOP_JUMPXEQKB then
            local lhs = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local bval = (aux % 2 ~= 0) and "true" or "false"
            local not_flag = (math.floor(aux / (2^31)) ~= 0)
            if not_flag then
                emit(ind .. "if " .. lhs .. " ~= " .. bval .. " then")
            else
                emit(ind .. "if " .. lhs .. " == " .. bval .. " then")
            end
            indent_level = indent_level + 1
            skip_until = pc + 1

        elseif op == LuauOpcode.LOP_JUMPXEQKN then
            local lhs = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local kidx = aux % (2^24)
            local not_flag = (math.floor(aux / (2^31)) ~= 0)
            local rhs = get_const_str(proto, kidx)
            local op_str = not_flag and " ~= " or " == "
            emit(ind .. "if " .. lhs .. op_str .. rhs .. " then")
            indent_level = indent_level + 1
            skip_until = pc + 1

        elseif op == LuauOpcode.LOP_JUMPXEQKS then
            local lhs = reg_name(proto, A, pc)
            local aux = code[pc + 1] or 0
            local kidx = aux % (2^24)
            local not_flag = (math.floor(aux / (2^31)) ~= 0)
            local rhs = get_const_str(proto, kidx)
            local op_str = not_flag and " ~= " or " == "
            emit(ind .. "if " .. lhs .. op_str .. rhs .. " then")
            indent_level = indent_level + 1
            skip_until = pc + 1

        -- ARITHMETIC: ADD, SUB, MUL, DIV, MOD, POW, IDIV
        elseif op == LuauOpcode.LOP_ADD then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " + " .. rhs)

        elseif op == LuauOpcode.LOP_SUB then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " - " .. rhs)

        elseif op == LuauOpcode.LOP_MUL then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " * " .. rhs)

        elseif op == LuauOpcode.LOP_DIV then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " / " .. rhs)

        elseif op == LuauOpcode.LOP_MOD then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " % " .. rhs)

        elseif op == LuauOpcode.LOP_POW then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " ^ " .. rhs)

        elseif op == LuauOpcode.LOP_IDIV then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " // " .. rhs)

        -- ARITHMETIC with constant: ADDK, SUBK, MULK, DIVK, MODK, POWK, IDIVK
        elseif op == LuauOpcode.LOP_ADDK then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = get_const_str(proto, C)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " + " .. rhs)

        elseif op == LuauOpcode.LOP_SUBK then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = get_const_str(proto, C)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " - " .. rhs)

        elseif op == LuauOpcode.LOP_MULK then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = get_const_str(proto, C)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " * " .. rhs)

        elseif op == LuauOpcode.LOP_DIVK then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = get_const_str(proto, C)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " / " .. rhs)

        elseif op == LuauOpcode.LOP_MODK then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = get_const_str(proto, C)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " % " .. rhs)

        elseif op == LuauOpcode.LOP_POWK then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = get_const_str(proto, C)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " ^ " .. rhs)

        elseif op == LuauOpcode.LOP_IDIVK then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = get_const_str(proto, C)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " // " .. rhs)

        -- SUBRK R(A) = K(B) - R(C)
        elseif op == LuauOpcode.LOP_SUBRK then
            local dst = reg_name(proto, A, pc)
            local lhs = get_const_str(proto, B)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " - " .. rhs)

        -- DIVRK R(A) = K(B) / R(C)
        elseif op == LuauOpcode.LOP_DIVRK then
            local dst = reg_name(proto, A, pc)
            local lhs = get_const_str(proto, B)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " / " .. rhs)

        -- AND / OR
        elseif op == LuauOpcode.LOP_AND then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " and " .. rhs)

        elseif op == LuauOpcode.LOP_OR then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = reg_name(proto, C, pc)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " or " .. rhs)

        elseif op == LuauOpcode.LOP_ANDK then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = get_const_str(proto, C)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " and " .. rhs)

        elseif op == LuauOpcode.LOP_ORK then
            local dst = reg_name(proto, A, pc)
            local lhs = reg_name(proto, B, pc)
            local rhs = get_const_str(proto, C)
            emit(ind .. var_decl(dst) .. dst .. " = " .. lhs .. " or " .. rhs)

        -- CONCAT
        elseif op == LuauOpcode.LOP_CONCAT then
            local dst = reg_name(proto, A, pc)
            local parts = {}
            for i = B, C do
                parts[#parts + 1] = reg_name(proto, i, pc)
            end
            emit(ind .. var_decl(dst) .. dst .. " = " .. table.concat(parts, " .. "))

        -- NOT / MINUS / LENGTH
        elseif op == LuauOpcode.LOP_NOT then
            local dst = reg_name(proto, A, pc)
            local src = reg_name(proto, B, pc)
            emit(ind .. var_decl(dst) .. dst .. " = not " .. src)

        elseif op == LuauOpcode.LOP_MINUS then
            local dst = reg_name(proto, A, pc)
            local src = reg_name(proto, B, pc)
            emit(ind .. var_decl(dst) .. dst .. " = -" .. src)

        elseif op == LuauOpcode.LOP_LENGTH then
            local dst = reg_name(proto, A, pc)
            local src = reg_name(proto, B, pc)
            emit(ind .. var_decl(dst) .. dst .. " = #" .. src)

        -- NEWTABLE
        elseif op == LuauOpcode.LOP_NEWTABLE then
            local dst = reg_name(proto, A, pc)
            emit(ind .. var_decl(dst) .. dst .. " = {}")
            -- Skip AUX
            skip_until = pc + 1

        -- DUPTABLE
        elseif op == LuauOpcode.LOP_DUPTABLE then
            local dst = reg_name(proto, A, pc)
            emit(ind .. var_decl(dst) .. dst .. " = {}")

        -- SETLIST
        elseif op == LuauOpcode.LOP_SETLIST then
            -- Internal table construction, usually handled by previous NEWTABLE
            -- Skip AUX
            skip_until = pc + 1

        -- FORNPREP (numeric for init)
        elseif op == LuauOpcode.LOP_FORNPREP then
            local init = reg_name(proto, A, pc)
            local limit = reg_name(proto, A + 1, pc)
            local step = reg_name(proto, A + 2, pc)
            local var = reg_name(proto, A + 3, pc)
            declared[var] = true
            emit(ind .. "for " .. var .. " = " .. init .. ", " .. limit .. ", " .. step .. " do")
            indent_level = indent_level + 1
            -- Loop ends at pc + 1 + D
            local end_pc = pc + 1 + D
            for_loop_ends[end_pc] = true

        -- FORNLOOP (numeric for step/check)
        elseif op == LuauOpcode.LOP_FORNLOOP then
            indent_level = math.max(depth + (depth > 0 and 1 or 0), indent_level - 1)
            ind = get_indent()
            emit(ind .. "end")

        -- FORGLOOP (generic for loop)
        elseif op == LuauOpcode.LOP_FORGLOOP then
            -- This is the loop-back part. Usually the prep already emitted "for ... in"
            indent_level = math.max(depth + (depth > 0 and 1 or 0), indent_level - 1)
            ind = get_indent()
            emit(ind .. "end")
            skip_until = pc + 1

        -- FORGPREP / FORGPREP_INEXT / FORGPREP_NEXT
        elseif op == LuauOpcode.LOP_FORGPREP
            or op == LuauOpcode.LOP_FORGPREP_INEXT
            or op == LuauOpcode.LOP_FORGPREP_NEXT then
            local iter = reg_name(proto, A, pc)
            local state = reg_name(proto, A + 1, pc)
            local ctrl = reg_name(proto, A + 2, pc)
            -- Variables from A+3 onwards
            local vars = {}
            -- We don't know how many vars; check debug info or default to common patterns
            local nvar = 1
            if op == LuauOpcode.LOP_FORGPREP_INEXT then
                nvar = 2 -- ipairs returns index, value
                vars = { reg_name(proto, A + 3, pc), reg_name(proto, A + 4, pc) }
            elseif op == LuauOpcode.LOP_FORGPREP_NEXT then
                nvar = 2 -- pairs returns key, value
                vars = { reg_name(proto, A + 3, pc), reg_name(proto, A + 4, pc) }
            else
                -- Check AUX for variable count in FORGLOOP
                local loop_pc = pc + 1 + D -- where FORGLOOP is
                if loop_pc <= ncode then
                    local loop_instr = code[loop_pc]
                    local loop_aux = code[loop_pc + 1]
                    if loop_aux then
                        nvar = loop_aux % 256
                    end
                end
                if nvar < 1 then nvar = 1 end
                for i = 1, nvar do
                    vars[i] = reg_name(proto, A + 2 + i, pc)
                end
            end

            for _, v in ipairs(vars) do declared[v] = true end
            emit(ind .. "for " .. table.concat(vars, ", ") .. " in " .. iter .. " do")
            indent_level = indent_level + 1

        -- GETVARARGS
        elseif op == LuauOpcode.LOP_GETVARARGS then
            local nresults = (B > 0) and (B - 1) or nil
            if nresults and nresults > 0 then
                local vars = {}
                for i = 0, nresults - 1 do
                    local name = reg_name(proto, A + i, pc)
                    vars[#vars + 1] = name
                end
                for _, v in ipairs(vars) do declared[v] = true end
                emit(ind .. "local " .. table.concat(vars, ", ") .. " = ...")
            else
                local name = reg_name(proto, A, pc)
                emit(ind .. var_decl(name) .. name .. " = ...")
            end

        -- PREPVARARGS
        elseif op == LuauOpcode.LOP_PREPVARARGS then
            -- Internal, skip

        -- LOADKX
        elseif op == LuauOpcode.LOP_LOADKX then
            local aux = code[pc + 1] or 0
            local dst = reg_name(proto, A, pc)
            local val = get_const_str(proto, aux)
            emit(ind .. var_decl(dst) .. dst .. " = " .. val)
            skip_until = pc + 1

        -- FASTCALL / FASTCALL1 / FASTCALL2 / FASTCALL2K
        elseif op == LuauOpcode.LOP_FASTCALL
            or op == LuauOpcode.LOP_FASTCALL1
            or op == LuauOpcode.LOP_FASTCALL2
            or op == LuauOpcode.LOP_FASTCALL2K then
            -- These are optimization hints, the actual CALL follows
            -- Skip, the CALL will handle it

        -- CAPTURE
        elseif op == LuauOpcode.LOP_CAPTURE then
            -- Handled by NEWCLOSURE/DUPCLOSURE skip

        -- COVERAGE
        elseif op == LuauOpcode.LOP_COVERAGE then
            -- Debug coverage, skip

        -- DEP_ opcodes (deprecated)
        elseif op == LuauOpcode.LOP_DEP_FORGLOOP_INEXT
            or op == LuauOpcode.LOP_DEP_FORGLOOP_NEXT then
            indent_level = math.max(depth + (depth > 0 and 1 or 0), indent_level - 1)
            ind = get_indent()
            emit(ind .. "end")

        else
            emit(ind .. "-- FLX: unhandled opcode " .. opname .. " (" .. op .. ")")
        end

        pc = pc + 1
        ::continue::
    end

    -- Close remaining for loops
    for end_pc, _ in pairs(for_loop_ends) do
        indent_level = math.max(depth + (depth > 0 and 1 or 0), indent_level - 1)
        emit(get_indent() .. "end")
    end

    -- Function footer
    if depth > 0 then
        indent_level = math.max(0, indent_level - 1)
        emit(get_indent() .. "end")
    end

    return table.concat(lines, "\n")
end

-- ==================================================
-- 6) STANDARD LUA DECODER (from FLX v1.0)
-- ==================================================
-- [Keeping the full standard Lua parser from v1.0 for .luac files]

local StandardDecoder = {}

local function read_string_std(data, pos, version)
    local len
    if version and version >= 0x53 then
        len, pos = read_varint(data, pos)
    else
        len = u32_le(data, pos); pos = pos + 4
    end
    if len == 0 then return "", pos end
    local actual_len = len
    if version and version < 0x53 and len > 0 then
        actual_len = len - 1
    end
    if pos + actual_len - 1 > #data then return "", pos end
    local s = string.sub(data, pos, pos + actual_len - 1)
    return s, pos + len
end

function StandardDecoder.parse_luac(data)
    if not data or #data < 12 then return nil, "data too short" end
    local pos = 1
    local sig = string.sub(data, pos, pos + 3); pos = pos + 4
    if sig ~= "\27Lua" then return nil, "not standard Lua bytecode" end
    local version = u8(data, pos); pos = pos + 1
    -- Skip rest of header for now, return version info
    return { version = version, data = data, pos = pos }
end

-- ==================================================
-- 7) MAIN API
-- ==================================================

function FLX.decompile_bytecode(data)
    if not data or #data < 2 then
        return { success = false, error = "Data too short" }
    end

    -- Detect format
    local first_byte = string.byte(data, 1)
    local is_standard_lua = (string.sub(data, 1, 4) == "\27Lua")
    local is_luau = (not is_standard_lua and first_byte >= 3 and first_byte <= 6)

    if is_luau then
        -- Luau bytecode
        local chunk, err = LuauDecoder.parse(data)
        if not chunk then
            return { success = false, error = err or "Luau parse failed" }
        end

        local main_idx = chunk.main_proto
        if not main_idx or main_idx < 1 then
            -- Try first proto
            main_idx = 1
        end

        local ok, source = pcall(decompile_proto_luau, chunk, main_idx, 0)
        if not ok then
            return { success = false, error = "Luau decompilation error: " .. tostring(source) }
        end

        return {
            success = true,
            source = "-- FLX Decompiler " .. FLX.version .. "\n"
                .. "-- Luau Bytecode v" .. chunk.version .. "\n\n"
                .. source,
            format = "luau",
            version = chunk.version,
        }

    elseif is_standard_lua then
        -- Standard Lua bytecode - use v1.0 pipeline
        return {
            success = false,
            error = "Standard Lua bytecode - use FLX v1.0 pipeline",
            format = "lua",
        }
    else
        -- Unknown format
        -- Try Luau anyway (some executors strip/modify first byte)
        local chunk, err = LuauDecoder.parse(data)
        if chunk then
            local main_idx = chunk.main_proto or 1
            local ok, source = pcall(decompile_proto_luau, chunk, main_idx, 0)
            if ok then
                return {
                    success = true,
                    source = "-- FLX Decompiler " .. FLX.version .. "\n-- Auto-detected Luau\n\n" .. source,
                    format = "luau",
                }
            end
        end

        return {
            success = false,
            error = "Unknown bytecode format (first byte: " .. first_byte .. ")",
        }
    end
end

-- Decompile Roblox Instance
function FLX.decompile_instance(instance)
    if not instance then
        return "-- FLX Error: nil instance"
    end

    local full_name = ""
    pcall(function() full_name = instance:GetFullName() end)

    -- Try direct source access
    local source_text = nil
    pcall(function() source_text = instance.Source end)
    if source_text and #source_text > 0 then
        return "-- FLX: Direct source from " .. full_name .. "\n" .. source_text
    end

    -- Try getscriptbytecode
    if getscriptbytecode then
        local ok, bc = pcall(getscriptbytecode, instance)
        if ok and bc and #bc > 1 then
            local result = FLX.decompile_bytecode(bc)
            if result.success then
                return "-- FLX Decompiled: " .. full_name .. "\n" .. result.source
            else
                -- Fallback to executor decompile
                if decompile then
                    local ok2, src = pcall(decompile, instance)
                    if ok2 and src then
                        return "-- FLX (fallback): " .. full_name .. "\n" .. src
                    end
                end
                return "-- FLX Error: " .. (result.error or "unknown") .. "\n-- Instance: " .. full_name
            end
        end
    end

    -- Fallback to executor's decompile
    if decompile then
        local ok, src = pcall(decompile, instance)
        if ok and src then
            return "-- FLX (executor fallback): " .. full_name .. "\n" .. src
        end
    end

    return "-- FLX: Cannot access bytecode for " .. full_name
end

-- Dex Explorer hook
function FLX.hook_dex()
    local ok = pcall(function()
        local original = decompile

        getgenv().decompile = function(target)
            if typeof(target) == "Instance" then
                return FLX.decompile_instance(target)
            elseif type(target) == "string" then
                local result = FLX.decompile_bytecode(target)
                if result.success then return result.source end
            end
            if original then return original(target) end
            return "-- FLX: unsupported"
        end

        getgenv().FLX = FLX
    end)
    return ok
end

-- Batch decompile
function FLX.decompile_children(parent, recursive)
    local results = {}
    local function scan(inst)
        local cn = inst.ClassName
        if cn == "LocalScript" or cn == "ModuleScript" or cn == "Script" then
            results[#results + 1] = {
                name = inst:GetFullName(),
                class = cn,
                source = FLX.decompile_instance(inst),
            }
        end
        if recursive then
            for _, child in ipairs(inst:GetChildren()) do
                scan(child)
            end
        end
    end
    scan(parent)
    return results
end

-- ==================================================
-- 8) CLI
-- ==================================================
if arg and arg[0] then
    local file = arg[1]
    if not file then
        print("FLX Decompiler " .. FLX.version)
        print("Usage: lua flx.lua <file.luac>")
    else
        local f = io.open(file, "rb")
        if f then
            local data = f:read("*a")
            f:close()
            local result = FLX.decompile_bytecode(data)
            if result.success then
                print(result.source)
            else
                print("-- Error: " .. result.error)
            end
        else
            print("-- Cannot open: " .. file)
        end
    end
end

return FLX
